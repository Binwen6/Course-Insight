# 数字设计和计算机体系结构
## Chapter 6

#### LDR
#### 机器语言
##### 数据处理指令
##### 存储器指令
##### 分支指令
##### 寻址模式
1. 直接寻址模式（Immediate Addressing Mode）：
操作数的地址就是指令中的一个固定数值，通常是一个立即数。例如，```MOV R1, #42``` 表示将立即数42存储到寄存器R1中。
2. 间接寻址模式（Indirect Addressing Mode）：
操作数的地址存储在另一个寄存器或者内存位置中，需要通过这个间接的地址获取最终的操作数。例如，```LDR R1, [R2]``` 表示将存储在R2指向的地址中的数据加载到寄存器R1中。
3. 基址寻址模式（Base Addressing Mode）：
操作数的地址由一个基址寄存器和一个偏移量相加得到。例如，```LDR R1, [R2, #8]``` 表示将存储在R2 + 8的地址中的数据加载到寄存器R1中。
4. 相对寻址模式（Relative Addressing Mode）：
操作数的地址是相对于指令下一条指令的地址计算的。通常用于分支指令。例如，BEQ label 表示在条件满足时跳转到标签处执行。
5. 索引寻址模式（Indexed Addressing Mode）：
操作数的地址由一个基址寄存器和一个索引寄存器相加得到。例如，```LDR R1, [R2, R3]``` 表示将存储在R2 + R3的地址中的数据加载到寄存器R1中。
6. 相对基址寻址模式（Relative Base Addressing Mode）：
操作数的地址是相对于一个基址寄存器和一个偏移量相加得到的。例如，```LDR R1, [R2, R3, LSL #2]``` 表示将存储在R2 + (R3 << 2)的地址中的数据加载到寄存器R1中。
##### 预索引
```
LDR R1, [R0, #4]!：
```
这是预索引模式。
在执行这条指令之前，R0 的值会先被更新，然后再用更新后的值进行内存访问。实际上，它相当于先执行 R0 = R0 + 4，然后再从新的 R0 地址处加载数据到 R1。

```
LDR R1, [R0, #4]：
```
这是非预索引模式。
在执行这条指令时，R0 的值不会被修改，加载的数据来自于 R0 + 4 的地址。这个地址计算是在访问内存之后进行的。

#### 叶函数和非叶函数
区别：
- 叶函数在栈帧中不需要使用链接寄存器**LR**
##### 画出栈的（使用）情况示意图
1. 函数调用前
2. 函数调用中
3. 函数调用后：与实际使用的所有栈帧相对应

## Chapter 7
### 微结构
微指令集：
- 数据处理指令：ADD/SUB/AND/ORR
- 存储器访问指令：LDR（最慢的时钟周期指令）/STR
- 分支指令：B

常见控制信号：
- RegW:
表示寄存器写使能（Register Write Enable）。当这个信号为1时，表示要将数据写入寄存器。
- ALUOp:
表示运算单元操作码（ALU Operation）。指定ALU（算术逻辑单元）进行的操作类型，例如加法、减法、逻辑与等。
- MemW:
表示内存写使能（Memory Write Enable）。当这个信号为1时，表示要将数据写入内存。
- RegSrc1:
表示寄存器数据源1（Register Source 1）。指示ALU的第一个操作数来源是哪一个寄存器。
- AdrSrc:
表示地址源（Address Source）。指示计算出的地址是从哪里获取的，可能是指令地址、数据地址等。
- NextPC:
表示下一条指令的地址（Next Program Counter）。指示计算出的下一条指令的地址。
- MemR:
表示内存读使能（Memory Read Enable）。当这个信号为1时，表示要从内存中读取数据。
- ALUSrc:
表示ALU的数据源选择（ALU Source）。指示ALU的第二个操作数来源是寄存器中的数据还是立即数。
- MemtoReg:
表示写回寄存器的数据来源（Memory to Register）。指示写回寄存器的数据是来自ALU的输出还是内存的数据。
- Branch:
表示是否发生分支（Branch）。当这个信号为1时，表示要执行分支指令。
- RegDst:
表示写回寄存器的目标选择（Register Destination）。指示写回寄存器的目标寄存器是从指令中提取的还是从其他逻辑计算得到的。
- BranchOp:
表示分支条件的类型（Branch Operation）。指示执行分支时使用的条件类型，例如等于、不等于等。
- MemRead:
表示内存读取使能（Memory Read）。当这个信号为1时，表示要执行内存读取操作。
- MemWrite:
表示内存写使能（Memory Write）。当这个信号为1时，表示要执行内存写入操作。
- ExtOp:
表示符号扩展的类型（Extension Operation）。指示在加载立即数时使用的符号扩展类型，例如零扩展、符号扩展等。
#### 单周期
##### 五个状态原件
1. 程序计数器
2. 寄存器文件
3. 状态寄存器
4. 指令存储器
5. 数据存储器
##### 时钟周期
- 寄存器建立时间$t_{setup}$不计入
- 多路选择器时间$t_{mux}$计入两遍
- 存储器读时间$t_{mem}$计入两遍
##### 信号故障
- 固定0故障：无论赋任何值，信号始终为0
- 固定1故障：无论赋任何值，信号始终为1
#### 多周期
特点：指令存储器和数据存储器合二为一/消除了两个加法器
#### 流水线
$FDEMW五级结构：$
1. 取指（Fetch）
2. 译码（Decode）
    - 状态寄存器读取
3. 执行（Execute）
4. 存储器访问（Memory）
5. 写回（Writeback）
    - 状态寄存器写入
##### 画出流水线的抽象视图
##### Conflicts Handling
###### 转发 forwarding
###### 停顿 stall
###### 冲刷 flush
### 性能分析
$CPI$：平均执行一条指令所需要的周期数
$IPC（吞吐率）$：平均一个周期所执行的指令条数
#### 实例
```
    MOV R0, #5
    MOV R1, #0
L1
    CMP R0, R1
    BEQ DONE
    SUB R0, R0, #1
    B L1
DONE
```
$$Total = 2DP+5(2DP+2Branch)+(1DP+1Branch)=13DP+11B\\Cycles = 13\times4+11\times3=85$$